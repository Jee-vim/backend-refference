# POSTGRESQL TERMINAL & TABLE CHEAT SHEET

## 1. PSQL SHELL / META-COMMANDS (Navigating the Terminal)
- `\l`                : List databases  
- `\c db_name`        : Connect to a specific database (or: `\c db_name user`)  
- `\conninfo`         : Show current connection info  
- `\dt`, `\dt+`       : List tables (with sizes and descriptions)  
- `\d schema.*`       : List objects in a schema  
- `\d table_name`     : Show table columns, types, indexes, constraints  
- `\df`               : List functions  
- `\dv`               : List views  
- `\di`               : List indexes  
- `\dp`               : Show access privileges (ACLs)  
- `\du`               : List roles/users  
- `\x`                : Toggle expanded output (good for wide rows)  
- `\timing on|off`    : Turn timing of queries on/off  
- `\set name value`   : Set a psql variable  
- `:'variable'`       : Use psql variable (e.g. `SELECT :'myvar';`)  
- `\g`                : Send query (same as semicolon if omitted)  
- `\g filename`       : Send query results to file  
- `\gset`             : Run query and store output columns into psql variables  
- `\o filename`       : Send all subsequent query output to file  
- `\e`                : Open query buffer in `$EDITOR`  
- `\watch seconds`    : Re-run the last query every N seconds (psql builtin)  
- `\copy ...`         : Client-side COPY (reads/writes from client host)  
- `\! command`        : Run shell command from psql  
- `\q`                : Quit

---

## 2. COMMON DATA TYPES & ID/GUID GUIDELINES
- Integers: `SMALLINT`, `INTEGER`, `BIGINT`  
- Serial/Identity (preferred modern approach):
  - `id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY`  
- UUID:
  - Use `gen_random_uuid()` (pgcrypto) or `uuid_generate_v4()` (uuid-ossp)  
  - `CREATE EXTENSION IF NOT EXISTS pgcrypto;`  
- Numeric/monetary: `NUMERIC(precision,scale)`  
- Timestamps: `TIMESTAMP WITH TIME ZONE` (`timestamptz`) vs `TIMESTAMP WITHOUT TIME ZONE`  
- `JSONB` for semi-structured data (fast, indexable)  
- Arrays: `text[]`, `integer[]`, etc.

---

## 3. CREATE / DROP / ALTER TABLE (examples)

```sql
-- Enable extension for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  price NUMERIC(10,2) DEFAULT 0.00,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  data JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);
```

Rename / drop / truncate / alter column examples:

```sql
-- Rename table
ALTER TABLE products RENAME TO items;

-- Add column
ALTER TABLE items ADD COLUMN stock_count INTEGER DEFAULT 0;

-- Drop column
ALTER TABLE items DROP COLUMN stock_count;

-- Rename column
ALTER TABLE items RENAME COLUMN old_name TO new_name;

-- Change data type
ALTER TABLE items ALTER COLUMN price TYPE NUMERIC(12,2);

-- Set / drop NOT NULL
ALTER TABLE items ALTER COLUMN name SET NOT NULL;
ALTER TABLE items ALTER COLUMN name DROP NOT NULL;
```

---

## 4. KEYS, CONSTRAINTS & INDEXES
- Primary key: `PRIMARY KEY` (single or composite)  
- Foreign key: `REFERENCES other_table(col) ON DELETE CASCADE/SET NULL/RESTRICT`  
- Unique constraint: `UNIQUE (col)` or `CREATE UNIQUE INDEX ...`  
- Check constraint: `CHECK (quantity >= 0)`  
- Partial unique index: unique constraint that applies only to rows matching a WHERE clause  
- Expression index: e.g., `LOWER(name)` for case-insensitive searches  
- GIN/GIST indexes for `jsonb`, arrays, full-text, trigram searches

Examples:

```sql
-- Basic index
CREATE INDEX idx_products_price ON products(price);

-- Unique partial index allowing NULLs
CREATE UNIQUE INDEX uniq_users_email
  ON users(email) WHERE email IS NOT NULL;

-- Expression index (case-insensitive)
CREATE INDEX idx_products_name_lower ON products(LOWER(name));

-- GIN index for JSONB
CREATE INDEX idx_products_data_gin ON products USING GIN (data);

-- Trigram index (pg_trgm extension) for fast LIKE '%foo%'
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE INDEX idx_products_name_trgm ON products USING GIN (name gin_trgm_ops);
```

---

## 5. DML: INSERT / SELECT / UPDATE / DELETE (and UPSERT)
- Basic INSERT:

```sql
INSERT INTO products (name, price, user_id)
VALUES ('Sprocket', 9.99, 'a0b1c2-...') RETURNING id, created_at;
```

- Upsert (INSERT ... ON CONFLICT):

```sql
INSERT INTO products (id, name, price)
VALUES ($1, $2, $3)
ON CONFLICT (id) DO UPDATE
  SET name = EXCLUDED.name, price = EXCLUDED.price
RETURNING *;
```

- `RETURNING` returns rows affected (handy for APIs)  
- Parameter placeholders: `$1`, `$2`, `$3` (psql uses `:var` or positional bind methods in clients)

- Select with filters, sorting, pagination:

```sql
SELECT * FROM products
WHERE price > $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3;
```

---

## 6. TRANSACTIONS & LOCKING

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
-- or ROLLBACK;
```

- Savepoints:

```sql
SAVEPOINT sp1;
-- do some operations
ROLLBACK TO SAVEPOINT sp1; -- partial rollback
RELEASE SAVEPOINT sp1;
```

- Row locking:
  - `SELECT ... FOR UPDATE` — exclusive lock on selected rows  
  - `SELECT ... FOR SHARE` — shared lock  
- Advisory locks:
  - `SELECT pg_advisory_lock(key);`
  - `SELECT pg_advisory_unlock(key);`

---

## 7. QUERY PATTERNS: JOINS, CTEs, WINDOW FUNCTIONS
- Joins: `INNER JOIN`, `LEFT/RIGHT OUTER JOIN`, `FULL OUTER JOIN`, `CROSS JOIN`  
- CTE:

```sql
WITH recent AS (
  SELECT * FROM products WHERE created_at > now() - interval '7 days'
)
SELECT * FROM recent WHERE price > 10;
```

- Recursive CTE:

```sql
WITH RECURSIVE subordinates AS (
  -- recursive definition
) SELECT * FROM subordinates;
```

- Window functions:

```sql
SELECT id, name, price,
       RANK() OVER (ORDER BY price DESC) AS rank_by_price,
       SUM(price) OVER () AS total_revenue
FROM products;
```

---

## 8. JSONB & FULL-TEXT SEARCH (basics)
- Query JSONB:

```sql
SELECT data->>'color' AS color
FROM products
WHERE data->>'color' = 'blue';

-- existence
SELECT * FROM products WHERE data ? 'tags';
```

- Index JSONB with GIN for fast lookups  
- Full-text search:

```sql
ALTER TABLE documents ADD COLUMN document_tsv tsvector;
UPDATE documents SET document_tsv = to_tsvector('english', coalesce(title,'') || ' ' || coalesce(body,''));
CREATE INDEX idx_documents_tsv ON documents USING GIN (document_tsv);

SELECT * FROM documents WHERE document_tsv @@ plainto_tsquery('english', 'search term');
```

---

## 9. IMPORT / EXPORT & COPY
- Server-side copy (file accessible by postgres user):

```sql
COPY products (id, name, price) FROM '/var/lib/postgresql/data/products.csv' CSV HEADER;
COPY products TO '/tmp/products_export.csv' CSV HEADER;
```

- Client-side (psql): `\copy products FROM 'localfile.csv' CSV HEADER`  
- Backups: `pg_dump`, `pg_restore`, `pg_dumpall`

---

## 10. BACKUP / RESTORE (quick)
- Logical backup:

```
pg_dump mydb > mydb.sql
```

- Custom format:

```
pg_dump -Fc -f mydb.dump mydb
pg_restore -d newdb mydb.dump
```

- `pg_dumpall` for globals (roles, tablespaces)

---

## 11. PERFORMANCE & MAINTENANCE
- `EXPLAIN` / `EXPLAIN ANALYZE` to inspect query plan and timing  
- `VACUUM` / `VACUUM ANALYZE`; `VACUUM FULL` (locks table — avoid when possible)  
- `REINDEX` to rebuild indexes  
- `ANALYZE` to refresh planner statistics  
- Ensure `autovacuum` is active  
- `pg_stat_statements` extension for query statistics  
- Use connection pooling (pgbouncer) for web apps

---

## 12. ROLES & PERMISSIONS

```sql
CREATE ROLE readonly NOINHERIT LOGIN PASSWORD 'secret';
GRANT CONNECT ON DATABASE mydb TO readonly;
GRANT USAGE ON SCHEMA public TO readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly;

-- Future tables:
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO readonly;
```

- Revoke privileges with `REVOKE`

---

## 13. COMMON ERRORS & TROUBLESHOOTING
- `relation "x" does not exist` — wrong `search_path` or schema; try `schema.table` or `SET search_path TO schema;`  
- `duplicate key value violates unique constraint` — inserting duplicate unique/PK value  
- `invalid input syntax for type integer` — wrong data type / bad cast  
- Foreign key violation — missing referenced row  
- Permission denied — missing `GRANT`s or wrong connecting role

---

## 14. TIPS & BEST PRACTICES
- Always use parameterized queries in app code (avoid SQL injection)  
- Prefer explicit schema qualification for critical objects (e.g., `schema.table`)  
- Prefer identity columns over `SERIAL` for portability and correctness with sequences  
- Use `RETURNING` for inserts/updates to get generated IDs  
- Index columns used in `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`; consider write cost  
- Monitor bloat and schedule routine maintenance (`VACUUM`, `REINDEX`)  
- Use read replicas for read scaling  
- Use `EXPLAIN ANALYZE` to diagnose slow queries — adjust indexes or rewrite queries

---

## 15. Quick reference examples (psql meta + DML)

```sql
-- Show tables and table structure (psql commands below)
\l
\c mydb
\dt
\d+ products

-- Insert and return id
INSERT INTO products (name, price) VALUES ('Foo', 1.50) RETURNING id;

-- Upsert example
INSERT INTO products (id, name, price) VALUES (gen_random_uuid(), 'X', 2.00)
ON CONFLICT (id) DO UPDATE SET price = EXCLUDED.price RETURNING *;

-- Export using psql client-side
\copy products TO '/tmp/products.csv' CSV HEADER

-- Explain a slow query
EXPLAIN ANALYZE SELECT * FROM products WHERE price > 100 ORDER BY created_at DESC LIMIT 10;
```

